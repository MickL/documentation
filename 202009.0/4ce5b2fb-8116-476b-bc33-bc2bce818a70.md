The *Product* feature allows creating products, manage their characteristics and settings.

In Spryker Commerce OS, you create and manage products in the [Back Office](https://documentation.spryker.com/docs/general-back-office-overview). The product information you specify serves multiple purposes:

* Defines product characteristics.
* Affects the shop behavior. For example, filtering and search on the Storefront is based on product attributes. 
* It's used for internal calculations, like delivery costs based on the product weight.


## Product abstraction

A product can have multiple variants, such as size or color. Such product variations are called *product variants*, or *concrete products*. To distinguish between different product versions, keep track of their stock, and provide a better shopping experience, product variants are grouped under *abstract products*. 

### Product data that differ abstracts from concretes

The abstract product is the highest level of the product hierarchy. It does not have its own stock, but defines various default properties for its product variants. A product variant always belongs to one abstract product, has a distinctive stock, and is always different from another product variant with at least one [super product attribute](https://documentation.spryker.com/docs/en/product-attributes).
The following table summarizes differences between the abstract products and the product variants:

| Product data | Abstract Product | Product Variant |
| --- | --- | --- |
| SKU | v | v |
| Name | v | v |
| Description | v | v |
| Product attributes | v | v |
| Super attributes |  | v |
| Media assets | v | v |
| Stock |  | v |

### Products behavior on the Storefront
On the Storefront, only abstract products appear in the product catalog and can be searched for. The product variants are always a part of an abstract product. Therefore, abstract product and all its product variants share the same URL.

Le't consider an example illustrating the relation between abstract and concrete products and their behavior on the Storefront:

![image](https://spryker.s3.eu-central-1.amazonaws.com/docs/Features/Product+Management/Product+Abstraction/product-abstraction.png){height="" width=""}

In this example, a T-shirt, the abstract product, is available in sizes S, M, and L, which are three different product variants, each holding its own stock. When you search *T-shirt* on the Storefront, it's the abstract product that appears as the search result. Your customers can not buy the abstract product. On the product detail page, they have to select between the product variants S, M, L to put the *T-shirt* product to cart. 

:::(Info) (Note)
Grouping the product variants under an abstract product allows you to build a clear product hierarchy to provide great customer experience and to manage your products effectively. However, keep in mind that creating a product structure is a solid business decision that affects both the visual representation and behavior of your online store.
:::

## Product attributes

Attributes can serve different purposes and are therefore stored in different ways. They may be used not only for product management, but also to improve search and filter functionality in the shop.

You can create characteristic attributes for your products, like brand or special features. You can define specific values to help you and your customers distinguish between products. You can assign multiple attributes to products to simplify the filter and category functions. 

One way to describe a characteristic of a product is the attribute mechanism. It allows to store a list of key-value pairs. 


There are 4 possible locations where attributes can be stored.

Common attributes that are shared by all the variants of an abstract product are stored on the level of the abstract product. However if they contain language or locale specific data, the localized abstract product attributes are the right location.

If attributes like the size of the t-shirt distinguish variants, they are stored on a product level.

### Attribute key metadata
Redis can work with key value pairs as defined in the product attributes tables. However elastic search needs more information about the attributes semantic. Is the content of an attribute part of the fulltext search or is it used to sort the attribute. Therefore needed metadata is stored in the attribute meta data tables. These are used by the front end exporter to control which attributes of the product is stored where in the elastic search structure.

### Product attribute management
In Zed, product management attributes support creating and editing products. You can add keys for your attribute name and values, enabling the translation to different languages (localized). Multiple ways of handling translations are offered. The following examples highlight the use cases.

#### Example 1 for localized attributes and non-localized values
In a shop with two languages, product Y has the `weight` attribute with the `63.5 g` value. Translations are necessary for the attribute name and not the attribute value. 

In the database the `attribute.weight` key is saved. The key is translated into different languages via the glossary: 

Key = attribute.weight 
Value (en_EN) = Weight 
Value (de_DE) = Gewicht 

The attribute value `63.5 g` exists as a value key and serves as a key and a value at the same time:

Value (non-localized)=63.5 g 
What you see on the English version of the shop: Weight = 63.5 g 
What you see on the German version of the shop: Gewicht = 63.5 g  

#### Example 2 for localized attributes and values
  In a shop with two languages Product X exists with an attribute “**Protection Feature**” and an attribute value “*waterproof*”. Both, attribute name and value need translations. 

In the DB a key “**attribute.protection_feature**” is saved. The key can be translated into different languages via the glossary: 

Key = attribute.protection_feature 
Value (en_EN) = Protection Feature 
Value (de_DE) = Schutzfunktion 

The attribute value “waterproof” is now translated, a non-localized value (as in [Example 1](https://documentation.spryker.com/docs/product-attributes#example-1-for-localized-attributes-and-non-localized-values)) is not sufficient: 

Value (en_EN) = Waterproof 
Value (de_DE) = Wasserdicht 

What you see on the English version of the shop: 
Protection Feature = Waterproof 

What you see on the German version of the shop: 
Schutzfunktion = Wasserdicht  

#### Example 3 for different localized attributes and values for different languages

  Product Z has the attribute “length” and is sold in 3 countries, Germany, Ireland, and the United States. Due to the fact that the United States does not use the metric system, the attribute values should be displayed in feet in the US and in meters in Germany and Ireland. 
For this scenario there are two ways of doing it. One way **1** is to work with a non-localized attribute key for Germany and Ireland, and a localized key for the US, because (like in [Example 1](https://documentation.spryker.com/docs/product-attributes#example-1-for-localized-attributes-and-non-localized-values)) two languages could share the same translation for the attribute. The other way **2** is to add localized attribute keys and values for each language. 

**(1)Non-Localized key and localized key for the US** 
In the DB a key “attribute.length” is saved for non-localized values and a localized key “attribute.length.us” for the translations in the metric system. 

Key = attribute.length 
Value (en_IE) = Length 
Value (de_DE) = Länge 

Key = attribute.length.us 
Value (en_US) = Length 

Now for each of the attribute keys we add the attribute values, which are 1.5 meter for the Ireland and Germany, and 4.92 feet for the US. 

For the key “attribute.length” the value is: 
Value = 1.5 meter 

For the key “attribute.length.us” the value is: 
Value = 4.92 feet 

**(2)Localized keys for US, DE and IE** 
In the DB three localized keys, namely “attribute.length.de”, “attribute.length.ie”, and “attribute.length.us” are saved. 

Key = attribute.length.de 
Value (de_DE) = Länge 

Key = attribute.length.ie 
Value (en_IE) = Length 

Key = attribute.length.us 
Value (en_US) = Length 

Now for each of the attribute keys we add the attribute values. 

For the key “attribute.length.de” the value is: 
Value = 1.5 meter 

For the key “attribute.length.ie” the value is: 
Value = 1.5 meter 

For the key “attribute.length.us” the value is: 
Value = 4.92 feet 

What you see on the Irish and German versions of the shop: 
Length = 1.5 meter 
Länge = 1.5 meter 

What you see on the US version of the shop: 
Length = 4.92 feet  


## Attributes in the product management
Translations of attribute values in the Back Office are optional. Users may add new values when creating a new product. There are different input types: from text input to numerical values. To restrict attributes to pre-defined ones, you can disable adding new attribute values during product creation. All the attributes that are displayed in the attribute management are called *declared attributes*.

## Declared attributes
Declared attributes are the attributes that can be used in the PIM. 

There are two ways to declare an attribute. When you create an attribute, it is automatically declared and you can add them when creatinng products. Alternatively, you may import products with existing attributes. The imported attributes are displayed in the PIM, but cannot be edited. Only after adding the exact same attribute key to the list of attributes in the attribute management, it becomes available in the PIM.

## What are super attributes?
The Spryker Commerce OS product data model allows creating multiple variants of a product. For the shop to differentiate between product variants, some of their characteristics should be differerent. A super attribute must be added to every product variant in order to display multiple variants of an abstract product in the shop frontend (Unless there is only one variant, which makes the use of super attributes for differentiation purposes obsolete). Attributes become super attributes by marking them as such in the attribute management interface. Important to note is that the variants do not need to share the same super attributes in order to belong to the same abstract product. Here is are two examples:

(1) Abstract product X has concrete product A and B: A: Super attribute = (color:blue) B: Super attribute = (color:green)

(2) Abstract product Y has concrete products C and D: C: Super attribute = (color:red) D: Super attribute = (size: 45)

### Super attributes in the Spryker Commerce OS Demoshop
In this example on the product detail page there will be the possibility to select either the attribute color or the attribute size. For a variant to be selectable, it should have a unique combination of values for its super attributes compared to the other variants from the same abstract product.

![Product attribute management](https://spryker.s3.eu-central-1.amazonaws.com/docs/Features/Product+Management/Product+Attributes/product_attribute_management.png){height="" width=""}


The **super attribute** is the only way to tell a Spryker-based shop that a product contains multiple variants (or [concrete products](https://documentation.spryker.com/v5/docs/product-abstraction)) to allow your customer to select the right product.
Spryker supports an unlimited amount of super attributes for a given [abstract product](https://documentation.spryker.com/v5/docs/product-abstraction). See below to understand how abstract and concrete products work with super attributes.


### Creating product attributes

You can define attributes by importing them or inside the Backoffice:

* Define which attribute is a super attribute: [https://github.com/spryker-shop/b2c-demo-shop/blob/master/data/import/common/common/product_attribute_key.csv](https://github.com/spryker-shop/b2c-demo-shop/blob/master/data/import/common/common/product_attribute_key.csv)

* Define attribute configuration: [https://github.com/spryker-shop/b2c-demo-shop/blob/master/data/import/common/common/product_management_attribute.csv](https://github.com/spryker-shop/b2c-demo-shop/blob/master/data/import/common/common/product_management_attribute.csv)

### Hierarchy of Products

At Spryker, there are 2 product levels:
* Abstract
* Concrete

An abstract product can contain one or more concrete products. You can only link a concrete product to one abstract product.

#### Differences Between the Levels

Abstract product is the level where all the information about the product is located, such as title, description, images, prices, brand.
Concrete product is the level where all divergent information compared to the abstract product is located, such as size, color, images, prices. It is the level where the stock for the product is defined. It is the only level where super attributes must be defined.

#### Inheritance Between Levels

Whenever Spryker must display some information about a concrete product, information of the abstract product is merged with the concrete product's information. Information from the concrete product is more important than the information about the abstract product.

### Use Cases
The use cases below will help you understand how abstract products and concrete products with super attributes data are used and processed in a real online store.

#### Case 1

If you sell books, most of the time, they do not have variations. So you will structure such products in a Spryker-based shop as one abstract product and one concrete product.
The abstract product will contain all information about the product. The concrete product will only hold the stock information.

#### Case 2

You sell a product in two colors, blue and green. You have to structure such a product in a Spryker-based shop as one abstract product and two concrete products. Suppose the green variant is more expensive than the blue one. In this case, you must use a **super attribute** so your customers can select which variant they want to buy.
The abstract product will contain all information about the product.
The concrete products will contain the following  information:
* The blue variant will only hold the stock information and a color super attribute (blue value).
* The green variant will hold the stock information, a color super attribute (green value), and the price, which is different than that of the abstract product.

#### Case 3

You sell a product in five colors, four sizes, and three materials. You can have up to 5 x 4 x 3 = 60 variants to support all combinations. In your shop, you can structure such a product as one abstract product and up to 60 concrete products, or you can use the Product Group feature to have five abstract product (one for each color), and each abstract product will contain up to 12 concrete products (combinations for the sizes and the materials).
The abstract product will contain all information about the product. Each variant will only hold the stock information and the super attribute values for color, size, and material.



## Managing product information in a third-party product information management system
Besides the Back Office, you can maintain product information in an external Product Information Management (PIM) system. The data from the PIM systems can be exported to Spryker. An import interface transforms the incoming product data into a Spryker specific data structure and persists it. After that, the data is exported to Redis and Elasticsearch. This way, the Storefront can access the relevant product data very fast. After the import was finished, you can access the products in the Spryker Back Office.

![Product information management](https://spryker.s3.eu-central-1.amazonaws.com/docs/Features/Product+Management/Product/product_information_management.png){height="" width=""}

The Spryker Commerce OS supports integration of the following PIM systems:

* [Akeneo](https://documentation.spryker.com/docs/core-extension)
* [Censhare PIM](https://documentation.spryker.com/docs/censhare-pim)
* [Xentral](https://documentation.spryker.com/docs/xentral)





## Current Constraints

Currently, the feature has the following functional constraints which are going to be resolved in the future.

* When adding a product variant to an existing abstract product, you can only use the existing super attributes.

* To add another super attribute to variants, you need to recreate the abstract product with its concrete products from scratch.

* If you import a product without defining its attributes, you cannot edit the attributes in the Back Office.

@(Warning)()(We recommend defining all the atributes you want to use.)
